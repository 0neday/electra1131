//
//  rootfs_remount.cpp
//  multi_path
//
//  Created by CoolStar on 6/7/18.
//  Copyright Â© 2018 CoolStar. All rights reserved.
//

#include <stdio.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include "rootfs_remount.h"
#include "kmem.h"
#include "kutils.h"
#include "file_utils.h"
#include "patchfinder64.h"
#include "kexecute.h"
#include "offsetof.h"

uint64_t offset_vfs_context_current;
uint64_t offset_vnode_lookup;
uint64_t offset_vnode_put;
uint64_t offset_mount;

uint64_t get_vfs_context() {
    // vfs_context_t vfs_context_current(void)
    uint64_t vfs_context = kexecute(offset_vfs_context_current, 1, 0, 0, 0, 0, 0, 0);
    vfs_context = zm_fix_addr(vfs_context);
    return vfs_context;
}

int vnode_lookup(const char *path, int flags, uint64_t *vpp, uint64_t vfs_context){
    size_t len = strlen(path) + 1;
    
    uint64_t vnode = kalloc(sizeof(uint64_t));
    
    uint64_t ks = kalloc(len);
    kwrite(ks, path, len);
    
    int ret = (int)kexecute(offset_vnode_lookup, ks, 0, vnode, vfs_context, 0, 0, 0);
    if (ret != 0) {
        return -1;
    }
    
    *vpp = rk64(vnode);
    kfree(ks, len);
    kfree(vnode, sizeof(uint64_t));
    return 0;
}

int vnode_put(uint64_t vnode){
    return (int)kexecute(offset_vnode_put, vnode, 0, 0, 0, 0, 0, 0);
}

int kern_mount(uint64_t kernproc ,char *type, char *path, int flags, void *data){
    typedef struct __attribute__((packed)) {
        uint64_t type;
        uint64_t path;
        uint64_t flags;
        uint64_t data;
    } mount_args_ios113;
    
    size_t typelen = strlen(type) + 1;
    uint64_t ktype = kalloc(typelen);
    kwrite(ktype, type, typelen);
    
    size_t pathlen = strlen(path) + 1;
    uint64_t kpath = kalloc(pathlen);
    kwrite(kpath, path, pathlen);
    
    mount_args_ios113 margs;
    margs.type = ktype;
    margs.path = kpath;
    margs.flags = 0;
    margs.data = (uint64_t)data;
    
    printf("Mount Args: 0x%llx, 0x%llx, 0x%llx, 0x%llx\n", ktype, kpath, (uint64_t)0, (uint64_t)data);
    
    uint64_t kargs = kalloc(sizeof(mount_args_ios113));
    kwrite(kargs, &margs, sizeof(mount_args_ios113));
    
    uint64_t retval = kalloc(sizeof(uint32_t));
    int ret = (int)kexecute(offset_mount, kernproc, kargs, retval, 0, 0, 0, 0);
    uint32_t kret = rk32(retval);
    kfree(retval, sizeof(uint32_t));
    
    printf("kern_mount: ret: %d. kret: %d\n", ret, kret);
    
    kfree(kargs, sizeof(mount_args_ios113));
    kfree(kpath, pathlen);
    kfree(ktype, typelen);
    return ret;
}

uint64_t getVnodeAtPath(uint64_t vfs_context, char *path){
    uint64_t *vpp = (uint64_t *)malloc(sizeof(uint64_t));
    int ret = vnode_lookup(path, O_RDONLY, vpp, vfs_context);
    if (ret != 0){
        printf("unable to get vnode from path for %s\n", path);
        return -1;
    }
    uint64_t vnode = *vpp;
    free(vpp);
    
    return vnode;
}

int remountRootAsRW(uint64_t slide, uint64_t kern_proc, uint64_t our_proc){
    if (!getOffsets(slide)){
        return -1;
    }
    uint64_t kernucred = rk64(kern_proc+0x100);
    uint64_t ourucred = rk64(our_proc+0x100);
    
    uint64_t vfs_context = get_vfs_context();
    
    uint64_t _rootvnode = find_rootvnode();
    uint64_t rootfs_vnode = rk64(_rootvnode);
    uint64_t v_mount = rk64(rootfs_vnode + offsetof_v_mount);
    uint32_t v_flag = rk32(v_mount + offsetof_mnt_flag);
    
    printf("Flags for root: 0x%x\n", v_flag);
    
    /*uint64_t test_rootvnode = getVnodeAtPath(vfs_context, "/");
    uint64_t test_v_mount = rk64(test_rootvnode + offsetof_v_mount);
    uint32_t test_v_flag = rk32(test_v_mount + offsetof_mnt_flag);
    
    printf("Flags for test root: 0x%x\n", test_v_flag);
    
    if (!(v_flag & MNT_RDONLY)){
        printf("Already have read/write rootfs.\n");
        return 0;
    }*/
    
    char *dev_path = strdup("/dev/disk0s1s1");
    uint64_t devVnode = getVnodeAtPath(vfs_context, dev_path);
    uint64_t specInfo = rk64(devVnode + offsetof_v_specinfo);
    
    printf("Existing specinfo for /dev/disk0s1s1: 0x%llx\n", specInfo);
    
    printf("Existing spec flags for /dev/disk0s1s1: 0x%x\n", rk32(specInfo + offsetof_si_flags));
    
/*    //cleanup
    vnode_put(devVnode);
    //vnode_put(test_rootvnode);
    
    return 0;
#warning remove this return statement (as well as the stuff above marked under cleanup) if you dare to remount rootfs*/
    
    wk32(specInfo + offsetof_si_flags, 0); //clear dev vnode's v_specflags
    
    if (file_exists("/var/rootfsmnt"))
        rmdir("/var/rootfsmnt");
    
    if (file_exists("/var/mobile/rootfsmnt"))
        rmdir("/var/mobile/rootfsmnt");
    
    mkdir("/var/mobile/rootfsmnt", 0755);
    chown("/var/mobile/rootfsmnt", 0, 0);
    
    /*int forkAndMountAPFS = fork();
    if (forkAndMountAPFS > 0){
        waitpid(forkAndMountAPFS, NULL, 0);
    } else if (forkAndMountAPFS == 0){
        const char *args_mount_apfs[] = {"mount_apfs", "/dev/disk0s1s1", "/var/mobile/rootfsmnt", NULL};
        execv("/sbin/mount_apfs", (char **)&args_mount_apfs);
        printf("Child should never reach here!\n");
        exit(-1);
    } else {
        printf("Unable to fork!\n");
    }*/
    
    printf("Temporarily setting kern ucred\n");
    
    wk64(our_proc+0x100, kernucred);
    
    int rvtmp = mount("apfs", "/var/mobile/rootfsmnt", 0, (void *)&dev_path);
    printf("mounting: %d\n", rvtmp);
    
    printf("Restoring our ucred\n");
    
    wk64(our_proc+0x100, ourucred);
    
    /*int rvtmp = kern_mount(kern_proc, "apfs", "/var/mobile/rootfsmnt", 0, (void *)&dev_path);
    printf("mounting: %d\n", rvtmp);*/
    
    uint64_t newmount_vnode = getVnodeAtPath(vfs_context, "/var/mobile/rootfsmnt");
    uint64_t newmount_mount = rk64(newmount_vnode + offsetof_v_mount);
    uint64_t newmount_data = rk64(newmount_mount + offsetof_mnt_data);
    uint32_t newmount_flag = rk32(newmount_mount + offsetof_mnt_flag);
    
    printf("Data for new_mount: 0x%llx\n", newmount_data);
    printf("Vnode for new mount: 0x%llx\n", newmount_vnode);
    printf("Flags for new_mount: 0x%x\n", newmount_flag);
    
    vnode_put(devVnode);
    vnode_put(newmount_vnode);
    return 0;
    
    v_flag = v_flag & ~MNT_NOSUID;
    v_flag = v_flag & ~MNT_RDONLY;
    wk32(v_mount + offsetof_mnt_flag, v_flag & ~MNT_ROOTFS);
    
    int rv = mount("apfs", "/", MNT_UPDATE, (void *)&dev_path);
    printf("remounting: %d\n", rv);
    
    v_mount = rk64(rootfs_vnode + offsetof_v_mount);
    wk32(v_mount + offsetof_mnt_flag, v_flag);
    
    wk64(v_mount + offsetof_mnt_data, newmount_data);
    
    int fd = open("/.bit_of_fun", O_RDONLY);
    if (fd == -1) {
        fd = creat("/.bit_of_fun", 0644);
    } else {
        printf("File already exists!\n");
    }
    close(fd);
    
    printf("Did we mount / as read+write? %s\n", file_exists("/.bit_of_fun") ? "yes" : "no");
    
    unlink("/.bit_of_fun");
    
    //cleanup
    vnode_put(devVnode);
    //vnode_put(test_rootvnode);
    
    return 0;
}
