//
//  rootfs_remount.cpp
//  multi_path
//
//  Created by CoolStar on 6/7/18.
//  Copyright Â© 2018 CoolStar. All rights reserved.
//

#include <stdio.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include "rootfs_remount.h"
#include "kmem.h"
#include "kutils.h"
#include "file_utils.h"
#include "patchfinder64.h"
#include "kexecute.h"
#include "offsetof.h"

uint64_t offset_vnode_getfromfd;
uint64_t offset_vfs_context_current;

uint64_t get_vfs_context() {
    // vfs_context_t vfs_context_current(void)
    uint64_t vfs_context = kexecute(offset_vfs_context_current, 1, 0, 0, 0, 0, 0, 0);
    vfs_context = zm_fix_addr(vfs_context);
    return vfs_context;
}

int get_vnode_fromfd(uint64_t vfs_context, int fd, uint64_t *vpp) {
    uint64_t vnode = kalloc(sizeof(vnode_t *));
    
    int ret = (int)kexecute(offset_vnode_getfromfd, vfs_context, fd, vnode, 0, 0, 0, 0);
    if (ret != 0) {
        return -1;
    }
    
    *vpp = vnode;
    return 0;
}

uint64_t getVnodeAtPath(uint64_t vfs_context, char *path){
    int fd = open(path, O_RDONLY);
    if (fd < 0){
        printf("unable to open fd for %s\n", path);
        return -1;
    }
    uint64_t *vpp = (uint64_t *)malloc(sizeof(uint64_t));
    int ret = get_vnode_fromfd(vfs_context, fd, vpp);
    if (ret != 0){
        printf("unable to get vnode from fd for %s\n", path);
        return -1;
    }
    uint64_t vnode = rk64(*vpp);
    free(vpp);
    return vnode;
}

int remountRootAsRW(){
    if (!getOffsets()){
        return -1;
    }
    
    return 0;
#warning remove this return statement if you dare to remount rootfs
    
    uint64_t vfs_context = get_vfs_context();
    
    uint64_t _rootvnode = find_rootvnode();
    uint64_t rootfs_vnode = rk64(_rootvnode);
    uint64_t v_mount = rk64(rootfs_vnode + offsetof_v_mount);
    uint32_t v_flag = rk32(v_mount + offsetof_mnt_flag);
    
    if (!(v_flag & MNT_RDONLY)){
        printf("Already have read/write rootfs.\n");
        return 0;
    }
    
    char *dev_path = strdup("/dev/disk0s1s1");
    uint64_t devVnode = getVnodeAtPath(vfs_context, dev_path);
    uint64_t specInfo = rk64(devVnode + offsetof_v_specinfo);
    wk64(specInfo + offsetof_si_flags, 0); //clear dev vnode's v_specflags
    
    if (file_exists("/var/rootfsmnt"))
        rmdir("/var/rootfsmnt");
    
    mkdir("/var/rootfsmnt", 0755);
    chown("/var/rootfsmnt", 0, 0);
    
    int forkAndMountAPFS = fork();
    if (forkAndMountAPFS > 0){
        waitpid(forkAndMountAPFS, NULL, 0);
    } else if (forkAndMountAPFS == 0){
        const char *args_mount_apfs[] = {"mount_apfs", "-u", "0", "-g", "0", "/dev/disk0s1s1", "/var/rootfsmnt", NULL};
        execv("/sbin/mount_apfs", (char **)&args_mount_apfs);
        printf("Child should never reach here!\n");
        exit(-1);
    } else {
        printf("Unable to fork!\n");
    }
    
    uint64_t newmount_vnode = getVnodeAtPath(vfs_context, "/var/rootfsmnt");
    uint64_t newmount_mount = rk64(newmount_vnode + offsetof_v_mount);
    uint64_t newmount_data = rk64(newmount_mount + offsetof_mnt_data);
    
    v_flag = v_flag & ~MNT_NOSUID;
    v_flag = v_flag & ~MNT_RDONLY;
    wk32(v_mount + offsetof_mnt_flag, v_flag & ~MNT_ROOTFS);
    
    int rv = mount("apfs", "/", MNT_UPDATE, (void *)&dev_path);
    printf("remounting: %d\n", rv);
    
    v_mount = rk64(rootfs_vnode + offsetof_v_mount);
    wk32(v_mount + offsetof_mnt_flag, v_flag);
    
    wk64(v_mount + offsetof_mnt_data, newmount_data);
    
    int fd = open("/.bit_of_fun", O_RDONLY);
    if (fd == -1) {
        fd = creat("/.bit_of_fun", 0644);
    } else {
        printf("File already exists!\n");
    }
    close(fd);
    
    printf("Did we mount / as read+write? %s\n", file_exists("/.bit_of_fun") ? "yes" : "no");
    
    unlink("/.bit_of_fun");
    
    return 0;
}
